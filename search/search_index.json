{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Signified","text":"<p>Documentation: https://dougmercer.github.io/signified</p> <p>Source Code: https://github.com/dougmercer/signified</p> <p>A Python library for reactive programming (with kind-of working type narrowing).</p>"},{"location":"#getting-started","title":"Getting started","text":"<pre><code>pip install signified\n</code></pre>"},{"location":"#why-care","title":"Why care?","text":"<p><code>signified</code> is a reactive programming library that implements two primary data structures: <code>Signal</code> and <code>Computed</code>.</p> <p>Both of these objects implement the Observer and Observable design patterns. This means that they can notify other Observers if they change, and they can subscribe to be notified if another Observable changes.</p> <p>This allows us to create a network of computation, where one value being modified can trigger other objects to update.</p> <p>This allows us to write more declarative code, like,</p> <pre><code>x = Signal(3)\nx_squared = x ** 2  # currently equal to 9\nx.value = 10  # Will immediately notify x_squared, whose value will become 100.\n</code></pre> <p>Here, <code>x_squared</code> became a reactive expression (more specifically, a <code>Computed</code> object) whose value is always equal to <code>x ** 2</code>. Neat!</p> <p><code>signified</code>'s <code>Signal</code> object effective gives us a container which stores a value, and <code>Computed</code> gives us a container to store the current value of a function. In the above example, we generated the Computed object on-the-fly using overloaded Python operators like <code>**</code>, but we could have just as easily done,</p> <pre><code>from signified import computed\n\n@computed\ndef power(x, n):\n    return x**n\n\nx_squared = power(x, 2)  # equivalent to the above\n</code></pre> <p>Together, these data structures allow us to implement a wide variety of capabilities. In particular, I wrote this library to make my to-be-released animation library easier to maintain and more fun to work with.</p>"},{"location":"#what-do-you-mean-by-kind-of-working-type-narrowing","title":"... what do you mean by \"kind of working type narrowing\"?","text":"<p>Other reactive Python libraries don't really attempt to implement type hints (e.g., param).</p> <p><code>signified</code> is type hinted and supports type narrowing even for nested reactive values.</p> <pre><code>from signified import Signal\n\na = Signal(1.0)\nb = Signal(Signal(Signal(2)))\nreveal_type(a + b)  # Computed[float | int]\n</code></pre> <p>Unfortunately, for the time being, our type hints only work with <code>pyright</code>.</p>"},{"location":"#read-the-docs","title":"Read the docs!","text":"<p>Checkout https://dougmercer.github.io/signified to find out more.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>A reactive programming library for creating and managing reactive values and computations.</p> <p>This module provides tools for building reactive systems, where changes in one value automatically propagate to dependent values.</p> <p>Classes:</p> Name Description <code>Variable</code> <p>Abstract base class for reactive values.</p> <code>Signal</code> <p>A container for mutable reactive values.</p> <code>Computed</code> <p>A container for computed reactive values (from functions).</p> <p>Functions:</p> Name Description <code>unref</code> <p>Dereference a potentially reactive value.</p> <code>computed</code> <p>Decorator to create a reactive value from a function.</p> <code>reactive_method</code> <p>Decorator to create a reactive method.</p> <code>as_signal</code> <p>Convert a value to a <code>Signal</code> if it's not already a reactive value.</p> <code>has_value</code> <p>Type guard to check if an object has a value of a specific type.</p> <p>Attributes:</p> Name Type Description <code>ReactiveValue</code> <code>TypeAlias</code> <p>Union of Computed and <code>Signal</code> types.</p> <code>HasValue</code> <code>TypeAlias</code> <p>Union of basic types and reactive types.</p> <code>NestedValue</code> <code>TypeAlias</code> <p>Recursive type for arbitrarily nested reactive values.</p>"},{"location":"api_reference/#signified.HasValue","title":"<code>HasValue: TypeAlias = Union[T, Computed[T], Signal[T]]</code>  <code>module-attribute</code>","text":"<p>This object would return a value of type T when calling <code>unref(obj)</code>.</p> <p>This type alias represents any value that can be dereferenced, including plain values and reactive values.</p> See Also <ul> <li><code>Computed</code>: The class for computed reactive values.</li> <li><code>Signal</code>: The class for mutable reactive values.</li> <li><code>unref</code>: Function to dereference values.</li> </ul>"},{"location":"api_reference/#signified.NestedValue","title":"<code>NestedValue: TypeAlias = Union[T, '_HasValue[NestedValue[T]]']</code>  <code>module-attribute</code>","text":"<p>Insane recursive type hint to try to encode an arbitrarily nested reactive values.</p> <p>E.g., <code>float | Signal[float] | Signal[Signal[float]] | Signal[Signal[Signal[float]]].</code></p>"},{"location":"api_reference/#signified.ReactiveValue","title":"<code>ReactiveValue: TypeAlias = Union[Computed[T], Signal[T]]</code>  <code>module-attribute</code>","text":"<p>A reactive object that would return a value of type T when calling <code>unref</code><code>(obj)</code>.</p> <p>This type alias represents any reactive value, either a <code>Computed</code> or a <code>Signal</code>.</p> See Also <ul> <li><code>Computed</code>: The class for computed reactive values.</li> <li><code>Signal</code>: The class for mutable reactive values.</li> <li><code>unref</code>: Function to dereference values.</li> </ul>"},{"location":"api_reference/#signified.Computed","title":"<code>Computed</code>","text":"<p>               Bases: <code>Variable[T, T]</code></p> <p>A reactive value defined by a function.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], T]</code> <p>The function that computes the value.</p> required <code>dependencies</code> <code>Any</code> <p>Dependencies to observe.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>f</code> <code>Callable[[], T]</code> <p>The function that computes the value.</p> <code>_value</code> <code>T</code> <p>The current computed value.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>class Computed(Variable[T, T]):\n    \"\"\"A reactive value defined by a function.\n\n    Args:\n        f: The function that computes the value.\n        dependencies: Dependencies to observe.\n\n    Attributes:\n        f (Callable[[], T]): The function that computes the value.\n        _value (T): The current computed value.\n    \"\"\"\n\n    def __init__(self, f: Callable[[], T], dependencies: Any = None) -&gt; None:\n        super().__init__()\n        self.f = f\n        self.observe(dependencies)\n        self._value = unref(self.f())\n        self.notify()\n\n    def update(self) -&gt; None:\n        \"\"\"Update the value by re-evaluating the function.\"\"\"\n        new_value = self.f()\n        change = new_value != self._value\n        if isinstance(change, np.ndarray):\n            change = change.any()\n        elif callable(self._value):\n            change = True\n\n        if change:\n            self._value: T = new_value\n            self.notify()\n\n    @property\n    def value(self) -&gt; T:\n        \"\"\"Get the current value.\n\n        Returns:\n            The current value.\n        \"\"\"\n        return unref(self._value)\n</code></pre>"},{"location":"api_reference/#signified.Computed.value","title":"<code>value: T</code>  <code>property</code>","text":"<p>Get the current value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p>"},{"location":"api_reference/#signified.Computed.update","title":"<code>update()</code>","text":"<p>Update the value by re-evaluating the function.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the value by re-evaluating the function.\"\"\"\n    new_value = self.f()\n    change = new_value != self._value\n    if isinstance(change, np.ndarray):\n        change = change.any()\n    elif callable(self._value):\n        change = True\n\n    if change:\n        self._value: T = new_value\n        self.notify()\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn","title":"<code>ReactiveMixIn</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Methods for easily creating reactive values.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>class ReactiveMixIn(Generic[T]):\n    \"\"\"Methods for easily creating reactive values.\"\"\"\n\n    @property\n    def value(self) -&gt; T:\n        \"\"\"The current value of the reactive object.\"\"\"\n        ...\n\n    def notify(self) -&gt; None:\n        \"\"\"Notify all observers by calling their ``update`` method.\"\"\"\n        ...\n\n    @overload\n    def __getattr__(self, name: Literal[\"value\", \"_value\"]) -&gt; T: ...  # type: ignore\n\n    @overload\n    def __getattr__(self, name: str) -&gt; Computed[Any]: ...\n\n    def __getattr__(self, name: str) -&gt; Union[T, Computed[Any]]:\n        \"\"\"Create a reactive value for retrieving an attribute from ``self.value``.\n\n        Args:\n            name: The name of the attribute to access.\n\n        Returns:\n            A reactive value for the attribute access.\n\n        Raises:\n            AttributeError: If the attribute doesn't exist.\n\n        Note:\n            Type inference is poor whenever `__getattr__` is used.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; class Person:\n            ...     def __init__(self, name):\n            ...         self.name = name\n            &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n            &gt;&gt;&gt; result = s.name\n            &gt;&gt;&gt; result.value\n            'Alice'\n            &gt;&gt;&gt; s.value = Person(\"Bob\")\n            &gt;&gt;&gt; result.value\n            'Bob'\n\n            ```\n        \"\"\"\n        if name in {\"value\", \"_value\"}:\n            return super().__getattribute__(name)\n\n        if hasattr(self.value, name):\n            return computed(getattr)(self, name)\n        else:\n            return super().__getattribute__(name)\n\n    @overload\n    def __call__(self: \"ReactiveMixIn[Callable[..., R]]\", *args: Any, **kwargs: Any) -&gt; Computed[R]: ...\n\n    @overload\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any: ...\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Create a reactive value for calling `self.value(*args, **kwargs)`.\n\n        Args:\n            *args: Positional arguments to pass to the callable value.\n            **kwargs: Keyword arguments to pass to the callable value.\n\n        Returns:\n            A reactive value for the function call.\n\n        Raises:\n            ValueError: If the value is not callable.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; class Person:\n            ...     def __init__(self, name):\n            ...         self.name = name\n            ...     def greet(self):\n            ...         return f\"Hi, I'm {self.name}!\"\n            &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n            &gt;&gt;&gt; result = s.greet()\n            &gt;&gt;&gt; result.value\n            \"Hi, I'm Alice!\"\n            &gt;&gt;&gt; s.name = \"Bob\"\n            &gt;&gt;&gt; result.value\n            \"Hi, I'm Bob!\"\n\n            ```\n        \"\"\"\n        if not callable(self.value):\n            raise ValueError(\"Value is not callable.\")\n\n        def f(*args: Any, **kwargs: Any):\n            _f = getattr(self, \"value\")\n            return _f(*args, **kwargs)\n\n        return computed(f)(*args, **kwargs).observe([self, self.value])\n\n    def __abs__(self) -&gt; Computed[T]:\n        \"\"\"Return a reactive value for the absolute value of `self`.\n\n        Returns:\n            A reactive value for `abs(self.value)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(-5)\n            &gt;&gt;&gt; result = abs(s)\n            &gt;&gt;&gt; result.value\n            5\n            &gt;&gt;&gt; s.value = -10\n            &gt;&gt;&gt; result.value\n            10\n\n            ```\n        \"\"\"\n        return computed(abs)(self)\n\n    def bool(self) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for the boolean value of `self`.\n\n        Note:\n            `__bool__` cannot be implemented to return a non-`bool`, so it is provided as a method.\n\n        Returns:\n            A reactive value for `bool(self.value)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(1)\n            &gt;&gt;&gt; result = s.bool()\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = 0\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(bool)(self)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string of the current value.\n\n        Note:\n            This is not reactive.\n\n        Returns:\n            A string representation of `self.value`.\n        \"\"\"\n        return str(self.value)\n\n    @overload\n    def __round__(self) -&gt; Computed[int]: ...\n    @overload\n    def __round__(self, ndigits: None) -&gt; Computed[int]: ...\n    @overload\n    def __round__(self, ndigits: int) -&gt; Computed[float]: ...\n\n    def __round__(self, ndigits: int | None = None) -&gt; Computed[int] | Computed[float]:\n        \"\"\"Return a reactive value for the rounded value of self.\n\n        Args:\n            ndigits: Number of decimal places to round to.\n\n        Returns:\n            A reactive value for `round(self.value, ndigits)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(3.14159)\n            &gt;&gt;&gt; result = round(s, 2)\n            &gt;&gt;&gt; result.value\n            3.14\n            &gt;&gt;&gt; s.value = 2.71828\n            &gt;&gt;&gt; result.value\n            2.72\n\n            ```\n        \"\"\"\n        if ndigits is None or ndigits == 0:\n            # When ndigits is None or 0, round returns an integer\n            return cast(Computed[int], computed(round)(self, ndigits=ndigits))\n        else:\n            # Otherwise, float\n            return cast(Computed[float], computed(round)(self, ndigits=ndigits))\n\n    def __ceil__(self) -&gt; Computed[int]:\n        \"\"\"Return a reactive value for the ceiling of `self`.\n\n        Returns:\n            A reactive value for `math.ceil(self.value)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; from math import ceil\n            &gt;&gt;&gt; s = Signal(3.14)\n            &gt;&gt;&gt; result = ceil(s)\n            &gt;&gt;&gt; result.value\n            4\n            &gt;&gt;&gt; s.value = 2.01\n            &gt;&gt;&gt; result.value\n            3\n\n            ```\n        \"\"\"\n        return cast(Computed[int], computed(math.ceil)(self))\n\n    def __floor__(self) -&gt; Computed[int]:\n        \"\"\"Return a reactive value for the floor of `self`.\n\n        Returns:\n            A reactive value for `math.floor(self.value)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; from math import floor\n            &gt;&gt;&gt; s = Signal(3.99)\n            &gt;&gt;&gt; result = floor(s)\n            &gt;&gt;&gt; result.value\n            3\n            &gt;&gt;&gt; s.value = 4.01\n            &gt;&gt;&gt; result.value\n            4\n\n            ```\n        \"\"\"\n        return cast(Computed[int], computed(math.floor)(self))\n\n    def __invert__(self) -&gt; Computed[T]:\n        \"\"\"Return a reactive value for the bitwise inversion of `self`.\n\n        Returns:\n            A reactive value for `~self.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(5)\n            &gt;&gt;&gt; result = ~s\n            &gt;&gt;&gt; result.value\n            -6\n            &gt;&gt;&gt; s.value = -3\n            &gt;&gt;&gt; result.value\n            2\n\n            ```\n        \"\"\"\n        return computed(operator.inv)(self)\n\n    def __neg__(self) -&gt; Computed[T]:\n        \"\"\"Return a reactive value for the negation of `self`.\n\n        Returns:\n            A reactive value for `-self.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(5)\n            &gt;&gt;&gt; result = -s\n            &gt;&gt;&gt; result.value\n            -5\n            &gt;&gt;&gt; s.value = -3\n            &gt;&gt;&gt; result.value\n            3\n\n            ```\n        \"\"\"\n        return computed(operator.neg)(self)\n\n    def __pos__(self) -&gt; Computed[T]:\n        \"\"\"Return a reactive value for the positive of self.\n\n        Returns:\n            A reactive value for `+self.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(-5)\n            &gt;&gt;&gt; result = +s\n            &gt;&gt;&gt; result.value\n            -5\n            &gt;&gt;&gt; s.value = 3\n            &gt;&gt;&gt; result.value\n            3\n\n            ```\n        \"\"\"\n        return computed(operator.pos)(self)\n\n    def __trunc__(self) -&gt; Computed[T]:\n        \"\"\"Return a reactive value for the truncated value of `self`.\n\n        Returns:\n            A reactive value for `math.trunc(self.value)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; from math import trunc\n            &gt;&gt;&gt; s = Signal(3.99)\n            &gt;&gt;&gt; result = trunc(s)\n            &gt;&gt;&gt; result.value\n            3\n            &gt;&gt;&gt; s.value = -4.01\n            &gt;&gt;&gt; result.value\n            -4\n\n            ```\n        \"\"\"\n        return computed(math.trunc)(self)\n\n    def __add__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the sum of `self` and `other`.\n\n        Args:\n            other: The value to add.\n\n        Returns:\n            A reactive value for `self.value + other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(5)\n            &gt;&gt;&gt; result = s + 3\n            &gt;&gt;&gt; result.value\n            8\n            &gt;&gt;&gt; s.value = 10\n            &gt;&gt;&gt; result.value\n            13\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.add\n        return computed(f)(self, other)\n\n    def __and__(self, other: HasValue[Y]) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for the bitwise AND of self and other.\n\n        Args:\n            other: The value to AND with.\n\n        Returns:\n            A reactive value for `self.value &amp; other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(True)\n            &gt;&gt;&gt; result = s &amp; False\n            &gt;&gt;&gt; result.value\n            False\n            &gt;&gt;&gt; s.value = True\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.and_)(self, other)\n\n    def contains(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for whether `other` is in `self`.\n\n        Args:\n            other: The value to check for containment.\n\n        Returns:\n            A reactive value for `other in self.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal([1, 2, 3, 4])\n            &gt;&gt;&gt; result = s.contains(3)\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = [5, 6, 7, 8]\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.contains)(self, other)\n\n    def __divmod__(self, other: Any) -&gt; Computed[tuple[float, float]]:\n        \"\"\"Return a reactive value for the divmod of `self` and other.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A reactive value for `divmod(self.value, other)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(10)\n            &gt;&gt;&gt; result = divmod(s, 3)\n            &gt;&gt;&gt; result.value\n            (3, 1)\n            &gt;&gt;&gt; s.value = 20\n            &gt;&gt;&gt; result.value\n            (6, 2)\n\n            ```\n        \"\"\"\n        return cast(Computed[tuple[float, float]], computed(divmod)(self, other))\n\n    def is_not(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for whether `self` is not other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A reactive value for self.value is not other.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(10)\n            &gt;&gt;&gt; other = None\n            &gt;&gt;&gt; result = s.is_not(other)\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = None\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.is_not)(self, other)\n\n    def eq(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for whether `self` equals other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A reactive value for self.value == other.\n\n        Note:\n            We can't overload `__eq__` because it interferes with basic Python operations.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(10)\n            &gt;&gt;&gt; result = s.eq(10)\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = 25\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.eq)(self, other)\n\n    def __floordiv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the floor division of `self` by other.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A reactive value for self.value // other.value.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(20)\n            &gt;&gt;&gt; result = s // 3\n            &gt;&gt;&gt; result.value\n            6\n            &gt;&gt;&gt; s.value = 25\n            &gt;&gt;&gt; result.value\n            8\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.floordiv\n        return computed(f)(self, other)\n\n    def __ge__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for whether `self` is greater than or equal to other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A reactive value for self.value &gt;= other.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(10)\n            &gt;&gt;&gt; result = s &gt;= 5\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = 3\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.ge)(self, other)\n\n    def __gt__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for whether `self` is greater than other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A reactive value for self.value &gt; other.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(10)\n            &gt;&gt;&gt; result = s &gt; 5\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = 3\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.gt)(self, other)\n\n    def __le__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for whether `self` is less than or equal to `other`.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A reactive value for `self.value &lt;= other`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(5)\n            &gt;&gt;&gt; result = s &lt;= 5\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = 6\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.le)(self, other)\n\n    def __lt__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for whether `self` is less than `other`.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A reactive value for `self.value &lt; other`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(5)\n            &gt;&gt;&gt; result = s &lt; 10\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = 15\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.lt)(self, other)\n\n    def __lshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `self` left-shifted by `other`.\n\n        Args:\n            other: The number of positions to shift.\n\n        Returns:\n            A reactive value for `self.value &lt;&lt; other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(8)\n            &gt;&gt;&gt; result = s &lt;&lt; 2\n            &gt;&gt;&gt; result.value\n            32\n            &gt;&gt;&gt; s.value = 3\n            &gt;&gt;&gt; result.value\n            12\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.lshift\n        return computed(f)(self, other)\n\n    def __matmul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the matrix multiplication of `self` and `other`.\n\n        Args:\n            other: The value to multiply with.\n\n        Returns:\n            A reactive value for `self.value @ other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; s = Signal(np.array([1, 2]))\n            &gt;&gt;&gt; result = s @ np.array([[1, 2], [3, 4]])\n            &gt;&gt;&gt; result.value\n            array([ 7, 10])\n            &gt;&gt;&gt; s.value = np.array([2, 3])\n            &gt;&gt;&gt; result.value\n            array([11, 16])\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.matmul\n        return computed(f)(self, other)\n\n    def __mod__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `self` modulo `other`.\n\n        Args:\n            other: The divisor.\n\n        Returns:\n            A reactive value for `self.value % other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(17)\n            &gt;&gt;&gt; result = s % 5\n            &gt;&gt;&gt; result.value\n            2\n            &gt;&gt;&gt; s.value = 23\n            &gt;&gt;&gt; result.value\n            3\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.mod\n        return computed(f)(self, other)\n\n    def __mul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the product of `self` and `other`.\n\n        Args:\n            other: The value to multiply with.\n\n        Returns:\n            A reactive value for `self.value * other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(4)\n            &gt;&gt;&gt; result = s * 3\n            &gt;&gt;&gt; result.value\n            12\n            &gt;&gt;&gt; s.value = 5\n            &gt;&gt;&gt; result.value\n            15\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.mul\n        return computed(f)(self, other)\n\n    def __ne__(self, other: Any) -&gt; Computed[bool]:  # type: ignore[override]\n        \"\"\"Return a reactive value for whether `self` is not equal to `other`.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A reactive value for `self.value != other`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(5)\n            &gt;&gt;&gt; result = s != 5\n            &gt;&gt;&gt; result.value\n            False\n            &gt;&gt;&gt; s.value = 6\n            &gt;&gt;&gt; result.value\n            True\n\n            ```\n        \"\"\"\n        return computed(operator.ne)(self, other)\n\n    def __or__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for the bitwise OR of `self` and `other`.\n\n        Args:\n            other: The value to OR with.\n\n        Returns:\n            A reactive value for `self.value or other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(False)\n            &gt;&gt;&gt; result = s | True\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = True\n            &gt;&gt;&gt; result.value\n            True\n\n            ```\n        \"\"\"\n        return computed(operator.or_)(self, other)\n\n    def __rshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `self` right-shifted by `other`.\n\n        Args:\n            other: The number of positions to shift.\n\n        Returns:\n            A reactive value for `self.value &gt;&gt; other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(32)\n            &gt;&gt;&gt; result = s &gt;&gt; 2\n            &gt;&gt;&gt; result.value\n            8\n            &gt;&gt;&gt; s.value = 24\n            &gt;&gt;&gt; result.value\n            6\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.rshift\n        return computed(f)(self, other)\n\n    def __pow__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `self` raised to the power of `other`.\n\n        Args:\n            other: The exponent.\n\n        Returns:\n            A reactive value for `self.value ** other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(2)\n            &gt;&gt;&gt; result = s ** 3\n            &gt;&gt;&gt; result.value\n            8\n            &gt;&gt;&gt; s.value = 3\n            &gt;&gt;&gt; result.value\n            27\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.pow\n        return computed(f)(self, other)\n\n    def __sub__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the difference of `self` and `other`.\n\n        Args:\n            other: The value to subtract.\n\n        Returns:\n            A reactive value for `self.value - other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(10)\n            &gt;&gt;&gt; result = s - 3\n            &gt;&gt;&gt; result.value\n            7\n            &gt;&gt;&gt; s.value = 15\n            &gt;&gt;&gt; result.value\n            12\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.sub\n        return computed(f)(self, other)\n\n    def __truediv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `self` divided by `other`.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A reactive value for `self.value / other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(20)\n            &gt;&gt;&gt; result = s / 4\n            &gt;&gt;&gt; result.value\n            5.0\n            &gt;&gt;&gt; s.value = 30\n            &gt;&gt;&gt; result.value\n            7.5\n\n            ```\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.truediv\n        return computed(f)(self, other)\n\n    def __xor__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for the bitwise XOR of `self` and `other`.\n\n        Args:\n            other: The value to XOR with.\n\n        Returns:\n            A reactive value for `self.value ^ other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(True)\n            &gt;&gt;&gt; result = s ^ False\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = False\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.xor)(self, other)\n\n    def __radd__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the sum of `self` and `other`.\n\n        Args:\n            other: The value to add.\n\n        Returns:\n            A reactive value for `self.value + other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(5)\n            &gt;&gt;&gt; result = 3 + s\n            &gt;&gt;&gt; result.value\n            8\n            &gt;&gt;&gt; s.value = 10\n            &gt;&gt;&gt; result.value\n            13\n\n            ```\n        \"\"\"\n        f: Callable[[Y, T], T | Y] = operator.add\n        return computed(f)(other, self)\n\n    def __rand__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for the bitwise AND of `self` and `other`.\n\n        Args:\n            other: The value to AND with.\n\n        Returns:\n            A reactive value for `self.value and other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(True)\n            &gt;&gt;&gt; result = False &amp; s\n            &gt;&gt;&gt; result.value\n            False\n            &gt;&gt;&gt; s.value = True\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.and_)(other, self)\n\n    def __rdivmod__(self, other: Any) -&gt; Computed[tuple[float, float]]:\n        \"\"\"Return a reactive value for the divmod of `self` and `other`.\n\n        Args:\n            other: The value to use as the numerator.\n\n        Returns:\n            A reactive value for `divmod(other, self.value)`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(3)\n            &gt;&gt;&gt; result = divmod(10, s)\n            &gt;&gt;&gt; result.value\n            (3, 1)\n            &gt;&gt;&gt; s.value = 4\n            &gt;&gt;&gt; result.value\n            (2, 2)\n\n            ```\n        \"\"\"\n        return cast(Computed[tuple[float, float]], computed(divmod)(other, self))\n\n    def __rfloordiv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the floor division of `other` by `self`.\n\n        Args:\n            other: The value to use as the numerator.\n\n        Returns:\n            A reactive value for `other.value // self.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(3)\n            &gt;&gt;&gt; result = 10 // s\n            &gt;&gt;&gt; result.value\n            3\n            &gt;&gt;&gt; s.value = 4\n            &gt;&gt;&gt; result.value\n            2\n\n            ```\n        \"\"\"\n        f: Callable[[Y, T], T | Y] = operator.floordiv\n        return computed(f)(other, self)\n\n    def __rmod__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `other` modulo `self`.\n\n        Args:\n            other: The dividend.\n\n        Returns:\n            A reactive value for `other.value % self.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(3)\n            &gt;&gt;&gt; result = 10 % s\n            &gt;&gt;&gt; result.value\n            1\n            &gt;&gt;&gt; s.value = 4\n            &gt;&gt;&gt; result.value\n            2\n\n            ```\n        \"\"\"\n        f: Callable[[Y, T], T | Y] = operator.mod\n        return computed(f)(other, self)\n\n    def __rmul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the product of `self` and `other`.\n\n        Args:\n            other: The value to multiply with.\n\n        Returns:\n            A reactive value for `self.value * other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(4)\n            &gt;&gt;&gt; result = 3 * s\n            &gt;&gt;&gt; result.value\n            12\n            &gt;&gt;&gt; s.value = 5\n            &gt;&gt;&gt; result.value\n            15\n\n            ```\n        \"\"\"\n        f: Callable[[Y, T], T | Y] = operator.mul\n        return computed(f)(other, self)\n\n    def __ror__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for the bitwise OR of `self` and `other`.\n\n        Args:\n            other: The value to OR with.\n\n        Returns:\n            A reactive value for `self.value or other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(False)\n            &gt;&gt;&gt; result = True | s\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = True\n            &gt;&gt;&gt; result.value\n            True\n\n            ```\n        \"\"\"\n        return computed(operator.or_)(other, self)\n\n    def __rpow__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `self` raised to the power of `other`.\n\n        Args:\n            other: The base.\n\n        Returns:\n            A reactive value for `self.value ** other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(2)\n            &gt;&gt;&gt; result = 3 ** s\n            &gt;&gt;&gt; result.value\n            9\n            &gt;&gt;&gt; s.value = 3\n            &gt;&gt;&gt; result.value\n            27\n\n            ```\n        \"\"\"\n        f: Callable[[Y, T], T | Y] = operator.pow\n        return computed(f)(other, self)\n\n    def __rsub__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for the difference of `self` and `other`.\n\n        Args:\n            other: The value to subtract from.\n\n        Returns:\n            A reactive value for `other.value - self.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(10)\n            &gt;&gt;&gt; result = 15 - s\n            &gt;&gt;&gt; result.value\n            5\n            &gt;&gt;&gt; s.value = 15\n            &gt;&gt;&gt; result.value\n            0\n\n            ```\n        \"\"\"\n        f: Callable[[Y, T], T | Y] = operator.sub\n        return computed(f)(other, self)\n\n    def __rtruediv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a reactive value for `self` divided by `other`.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A reactive value for `self.value / other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(2)\n            &gt;&gt;&gt; result = 30 / s\n            &gt;&gt;&gt; result.value\n            15.0\n            &gt;&gt;&gt; s.value = 3\n            &gt;&gt;&gt; result.value\n            10.0\n\n            ```\n        \"\"\"\n        f: Callable[[Y, T], T | Y] = operator.truediv\n        return computed(f)(other, self)\n\n    def __rxor__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a reactive value for the bitwise XOR of `self` and `other`.\n\n        Args:\n            other: The value to XOR with.\n\n        Returns:\n            A reactive value for `self.value ^ other.value`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal(True)\n            &gt;&gt;&gt; result = False ^ s\n            &gt;&gt;&gt; result.value\n            True\n            &gt;&gt;&gt; s.value = False\n            &gt;&gt;&gt; result.value\n            False\n\n            ```\n        \"\"\"\n        return computed(operator.xor)(other, self)\n\n    def __getitem__(self, key: Any) -&gt; Computed[Any]:\n        \"\"\"Return a reactive value for the item or slice of `self`.\n\n        Args:\n            key: The index or slice to retrieve.\n\n        Returns:\n            A reactive value for `self.value[key]`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal([1, 2, 3, 4, 5])\n            &gt;&gt;&gt; result = s[2]\n            &gt;&gt;&gt; result.value\n            3\n            &gt;&gt;&gt; s.value = [10, 20, 30, 40, 50]\n            &gt;&gt;&gt; result.value\n            30\n\n            ```\n        \"\"\"\n        return computed(operator.getitem)(self, key)\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        \"\"\"Set an attribute on the underlying `self.value`.\n\n        Note:\n            It is necessary to set the attribute via the Signal, rather than the\n            underlying `signal.value`, to properly notify downstream observers\n            of changes. Reason being, mutable objects that, for example, fallback\n            to id comparison for equality checks will appear as if nothing changed\n            even if one of its attributes changed.\n\n        Args:\n            name: The name of the attribute to access.\n            value: The value to set it to.\n\n        Example:\n            ```py\n                &gt;&gt;&gt; class Person:\n                ...    def __init__(self, name: str):\n                ...        self.name = name\n                ...    def greet(self) -&gt; str:\n                ...        return f\"Hi, I'm {self.name}!\"\n                &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n                &gt;&gt;&gt; result = s.greet()\n                &gt;&gt;&gt; result.value\n                \"Hi, I'm Alice!\"\n                &gt;&gt;&gt; s.name = \"Bob\"  # Modify attribute on Person instance through the reactive value s\n                &gt;&gt;&gt; result.value\n                \"Hi, I'm Bob!\"\n\n            ```\n        \"\"\"\n        if name == \"_value\" or not hasattr(self, \"_value\"):\n            super().__setattr__(name, value)\n        elif hasattr(self.value, name):\n            setattr(self.value, name, value)\n            self.notify()\n        else:\n            super().__setattr__(name, value)\n\n    def __setitem__(self, key: Any, value: Any) -&gt; None:\n        \"\"\"Set an item on the underlying `self.value`.\n\n        Note:\n            It is necessary to set the item via the Signal, rather than the\n            underlying `signal.value`, to properly notify downstream observers\n            of changes. Reason being, mutable objects that, for example, fallback\n            to id comparison for equality checks will appear as if nothing changed\n            even an element of the object is changed.\n\n        Args:\n            key: The key to change.\n            value: The value to set it to.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; s = Signal([1, 2, 3])\n            &gt;&gt;&gt; result = computed(sum)(s)\n            &gt;&gt;&gt; result.value\n            6\n            &gt;&gt;&gt; s[1] = 4\n            &gt;&gt;&gt; result.value\n            8\n        \"\"\"\n        if isinstance(self.value, (list, dict)):\n            self.value[key] = value\n            self.notify()\n        else:\n            raise TypeError(f\"'{type(self.value).__name__}' object does not support item assignment\")\n\n    def where(self, a: HasValue[A], b: HasValue[B]) -&gt; Computed[A | B]:\n        \"\"\"Return a reactive value for `a` if `self` is `True`, else `b`.\n\n        Args:\n            a: The value to return if `self` is `True`.\n            b: The value to return if `self` is `False`.\n\n        Returns:\n            A reactive value for `a if self.value else b`.\n\n        Example:\n            ```py\n            &gt;&gt;&gt; condition = Signal(True)\n            &gt;&gt;&gt; result = condition.where(\"Yes\", \"No\")\n            &gt;&gt;&gt; result.value\n            'Yes'\n            &gt;&gt;&gt; condition.value = False\n            &gt;&gt;&gt; result.value\n            'No'\n\n            ```\n        \"\"\"\n\n        @computed\n        def ternary(a: A, b: B, self: Any) -&gt; A | B:\n            return a if self else b\n\n        return ternary(a, b, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.value","title":"<code>value: T</code>  <code>property</code>","text":"<p>The current value of the reactive object.</p>"},{"location":"api_reference/#signified.ReactiveMixIn.__abs__","title":"<code>__abs__()</code>","text":"<p>Return a reactive value for the absolute value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A reactive value for <code>abs(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = abs(s)\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = -10\n&gt;&gt;&gt; result.value\n10\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __abs__(self) -&gt; Computed[T]:\n    \"\"\"Return a reactive value for the absolute value of `self`.\n\n    Returns:\n        A reactive value for `abs(self.value)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(-5)\n        &gt;&gt;&gt; result = abs(s)\n        &gt;&gt;&gt; result.value\n        5\n        &gt;&gt;&gt; s.value = -10\n        &gt;&gt;&gt; result.value\n        10\n\n        ```\n    \"\"\"\n    return computed(abs)(self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__add__","title":"<code>__add__(other)</code>","text":"<p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s + 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __add__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the sum of `self` and `other`.\n\n    Args:\n        other: The value to add.\n\n    Returns:\n        A reactive value for `self.value + other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(5)\n        &gt;&gt;&gt; result = s + 3\n        &gt;&gt;&gt; result.value\n        8\n        &gt;&gt;&gt; s.value = 10\n        &gt;&gt;&gt; result.value\n        13\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.add\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__and__","title":"<code>__and__(other)</code>","text":"<p>Return a reactive value for the bitwise AND of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &amp; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s &amp; False\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __and__(self, other: HasValue[Y]) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for the bitwise AND of self and other.\n\n    Args:\n        other: The value to AND with.\n\n    Returns:\n        A reactive value for `self.value &amp; other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(True)\n        &gt;&gt;&gt; result = s &amp; False\n        &gt;&gt;&gt; result.value\n        False\n        &gt;&gt;&gt; s.value = True\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.and_)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<pre><code>__call__(*args: Any, **kwargs: Any) -&gt; Computed[R]\n</code></pre><pre><code>__call__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Create a reactive value for calling <code>self.value(*args, **kwargs)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callable value.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callable value.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>A reactive value for the function call.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not callable.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n...     def greet(self):\n...         return f\"Hi, I'm {self.name}!\"\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.greet()\n&gt;&gt;&gt; result.value\n\"Hi, I'm Alice!\"\n&gt;&gt;&gt; s.name = \"Bob\"\n&gt;&gt;&gt; result.value\n\"Hi, I'm Bob!\"\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Create a reactive value for calling `self.value(*args, **kwargs)`.\n\n    Args:\n        *args: Positional arguments to pass to the callable value.\n        **kwargs: Keyword arguments to pass to the callable value.\n\n    Returns:\n        A reactive value for the function call.\n\n    Raises:\n        ValueError: If the value is not callable.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; class Person:\n        ...     def __init__(self, name):\n        ...         self.name = name\n        ...     def greet(self):\n        ...         return f\"Hi, I'm {self.name}!\"\n        &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n        &gt;&gt;&gt; result = s.greet()\n        &gt;&gt;&gt; result.value\n        \"Hi, I'm Alice!\"\n        &gt;&gt;&gt; s.name = \"Bob\"\n        &gt;&gt;&gt; result.value\n        \"Hi, I'm Bob!\"\n\n        ```\n    \"\"\"\n    if not callable(self.value):\n        raise ValueError(\"Value is not callable.\")\n\n    def f(*args: Any, **kwargs: Any):\n        _f = getattr(self, \"value\")\n        return _f(*args, **kwargs)\n\n    return computed(f)(*args, **kwargs).observe([self, self.value])\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__ceil__","title":"<code>__ceil__()</code>","text":"<p>Return a reactive value for the ceiling of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.ceil(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import ceil\n&gt;&gt;&gt; s = Signal(3.14)\n&gt;&gt;&gt; result = ceil(s)\n&gt;&gt;&gt; result.value\n4\n&gt;&gt;&gt; s.value = 2.01\n&gt;&gt;&gt; result.value\n3\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __ceil__(self) -&gt; Computed[int]:\n    \"\"\"Return a reactive value for the ceiling of `self`.\n\n    Returns:\n        A reactive value for `math.ceil(self.value)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; from math import ceil\n        &gt;&gt;&gt; s = Signal(3.14)\n        &gt;&gt;&gt; result = ceil(s)\n        &gt;&gt;&gt; result.value\n        4\n        &gt;&gt;&gt; s.value = 2.01\n        &gt;&gt;&gt; result.value\n        3\n\n        ```\n    \"\"\"\n    return cast(Computed[int], computed(math.ceil)(self))\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__divmod__","title":"<code>__divmod__(other)</code>","text":"<p>Return a reactive value for the divmod of <code>self</code> and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(self.value, other)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = divmod(s, 3)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 20\n&gt;&gt;&gt; result.value\n(6, 2)\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __divmod__(self, other: Any) -&gt; Computed[tuple[float, float]]:\n    \"\"\"Return a reactive value for the divmod of `self` and other.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A reactive value for `divmod(self.value, other)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(10)\n        &gt;&gt;&gt; result = divmod(s, 3)\n        &gt;&gt;&gt; result.value\n        (3, 1)\n        &gt;&gt;&gt; s.value = 20\n        &gt;&gt;&gt; result.value\n        (6, 2)\n\n        ```\n    \"\"\"\n    return cast(Computed[tuple[float, float]], computed(divmod)(self, other))\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__floor__","title":"<code>__floor__()</code>","text":"<p>Return a reactive value for the floor of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.floor(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import floor\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = floor(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4.01\n&gt;&gt;&gt; result.value\n4\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __floor__(self) -&gt; Computed[int]:\n    \"\"\"Return a reactive value for the floor of `self`.\n\n    Returns:\n        A reactive value for `math.floor(self.value)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; from math import floor\n        &gt;&gt;&gt; s = Signal(3.99)\n        &gt;&gt;&gt; result = floor(s)\n        &gt;&gt;&gt; result.value\n        3\n        &gt;&gt;&gt; s.value = 4.01\n        &gt;&gt;&gt; result.value\n        4\n\n        ```\n    \"\"\"\n    return cast(Computed[int], computed(math.floor)(self))\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__floordiv__","title":"<code>__floordiv__(other)</code>","text":"<p>Return a reactive value for the floor division of <code>self</code> by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for self.value // other.value.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s // 3\n&gt;&gt;&gt; result.value\n6\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\n8\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __floordiv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the floor division of `self` by other.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A reactive value for self.value // other.value.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(20)\n        &gt;&gt;&gt; result = s // 3\n        &gt;&gt;&gt; result.value\n        6\n        &gt;&gt;&gt; s.value = 25\n        &gt;&gt;&gt; result.value\n        8\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.floordiv\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Return a reactive value for whether <code>self</code> is greater than or equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt;= other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __ge__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for whether `self` is greater than or equal to other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A reactive value for self.value &gt;= other.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(10)\n        &gt;&gt;&gt; result = s &gt;= 5\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = 3\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.ge)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__getattr__","title":"<code>__getattr__(name)</code>","text":"<pre><code>__getattr__(name: Literal['value', '_value']) -&gt; T\n</code></pre><pre><code>__getattr__(name: str) -&gt; Computed[Any]\n</code></pre> <p>Create a reactive value for retrieving an attribute from <code>self.value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <p>Returns:</p> Type Description <code>Union[T, Computed[Any]]</code> <p>A reactive value for the attribute access.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist.</p> Note <p>Type inference is poor whenever <code>__getattr__</code> is used.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.name\n&gt;&gt;&gt; result.value\n'Alice'\n&gt;&gt;&gt; s.value = Person(\"Bob\")\n&gt;&gt;&gt; result.value\n'Bob'\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Union[T, Computed[Any]]:\n    \"\"\"Create a reactive value for retrieving an attribute from ``self.value``.\n\n    Args:\n        name: The name of the attribute to access.\n\n    Returns:\n        A reactive value for the attribute access.\n\n    Raises:\n        AttributeError: If the attribute doesn't exist.\n\n    Note:\n        Type inference is poor whenever `__getattr__` is used.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; class Person:\n        ...     def __init__(self, name):\n        ...         self.name = name\n        &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n        &gt;&gt;&gt; result = s.name\n        &gt;&gt;&gt; result.value\n        'Alice'\n        &gt;&gt;&gt; s.value = Person(\"Bob\")\n        &gt;&gt;&gt; result.value\n        'Bob'\n\n        ```\n    \"\"\"\n    if name in {\"value\", \"_value\"}:\n        return super().__getattribute__(name)\n\n    if hasattr(self.value, name):\n        return computed(getattr)(self, name)\n    else:\n        return super().__getattribute__(name)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return a reactive value for the item or slice of <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The index or slice to retrieve.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value[key]</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4, 5])\n&gt;&gt;&gt; result = s[2]\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = [10, 20, 30, 40, 50]\n&gt;&gt;&gt; result.value\n30\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __getitem__(self, key: Any) -&gt; Computed[Any]:\n    \"\"\"Return a reactive value for the item or slice of `self`.\n\n    Args:\n        key: The index or slice to retrieve.\n\n    Returns:\n        A reactive value for `self.value[key]`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; result = s[2]\n        &gt;&gt;&gt; result.value\n        3\n        &gt;&gt;&gt; s.value = [10, 20, 30, 40, 50]\n        &gt;&gt;&gt; result.value\n        30\n\n        ```\n    \"\"\"\n    return computed(operator.getitem)(self, key)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Return a reactive value for whether <code>self</code> is greater than other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt; other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt; 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __gt__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for whether `self` is greater than other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A reactive value for self.value &gt; other.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(10)\n        &gt;&gt;&gt; result = s &gt; 5\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = 3\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.gt)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__invert__","title":"<code>__invert__()</code>","text":"<p>Return a reactive value for the bitwise inversion of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A reactive value for <code>~self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = ~s\n&gt;&gt;&gt; result.value\n-6\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n2\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __invert__(self) -&gt; Computed[T]:\n    \"\"\"Return a reactive value for the bitwise inversion of `self`.\n\n    Returns:\n        A reactive value for `~self.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(5)\n        &gt;&gt;&gt; result = ~s\n        &gt;&gt;&gt; result.value\n        -6\n        &gt;&gt;&gt; s.value = -3\n        &gt;&gt;&gt; result.value\n        2\n\n        ```\n    \"\"\"\n    return computed(operator.inv)(self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__le__","title":"<code>__le__(other)</code>","text":"<p>Return a reactive value for whether <code>self</code> is less than or equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt;= other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __le__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for whether `self` is less than or equal to `other`.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A reactive value for `self.value &lt;= other`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(5)\n        &gt;&gt;&gt; result = s &lt;= 5\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = 6\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.le)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__lshift__","title":"<code>__lshift__(other)</code>","text":"<p>Return a reactive value for <code>self</code> left-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &lt;&lt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(8)\n&gt;&gt;&gt; result = s &lt;&lt; 2\n&gt;&gt;&gt; result.value\n32\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n12\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __lshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `self` left-shifted by `other`.\n\n    Args:\n        other: The number of positions to shift.\n\n    Returns:\n        A reactive value for `self.value &lt;&lt; other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(8)\n        &gt;&gt;&gt; result = s &lt;&lt; 2\n        &gt;&gt;&gt; result.value\n        32\n        &gt;&gt;&gt; s.value = 3\n        &gt;&gt;&gt; result.value\n        12\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.lshift\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Return a reactive value for whether <code>self</code> is less than <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt; other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt; 10\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __lt__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for whether `self` is less than `other`.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A reactive value for `self.value &lt; other`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(5)\n        &gt;&gt;&gt; result = s &lt; 10\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = 15\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.lt)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__matmul__","title":"<code>__matmul__(other)</code>","text":"<p>Return a reactive value for the matrix multiplication of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value @ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; s = Signal(np.array([1, 2]))\n&gt;&gt;&gt; result = s @ np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; result.value\narray([ 7, 10])\n&gt;&gt;&gt; s.value = np.array([2, 3])\n&gt;&gt;&gt; result.value\narray([11, 16])\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __matmul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the matrix multiplication of `self` and `other`.\n\n    Args:\n        other: The value to multiply with.\n\n    Returns:\n        A reactive value for `self.value @ other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; s = Signal(np.array([1, 2]))\n        &gt;&gt;&gt; result = s @ np.array([[1, 2], [3, 4]])\n        &gt;&gt;&gt; result.value\n        array([ 7, 10])\n        &gt;&gt;&gt; s.value = np.array([2, 3])\n        &gt;&gt;&gt; result.value\n        array([11, 16])\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.matmul\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__mod__","title":"<code>__mod__(other)</code>","text":"<p>Return a reactive value for <code>self</code> modulo <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value % other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(17)\n&gt;&gt;&gt; result = s % 5\n&gt;&gt;&gt; result.value\n2\n&gt;&gt;&gt; s.value = 23\n&gt;&gt;&gt; result.value\n3\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __mod__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `self` modulo `other`.\n\n    Args:\n        other: The divisor.\n\n    Returns:\n        A reactive value for `self.value % other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(17)\n        &gt;&gt;&gt; result = s % 5\n        &gt;&gt;&gt; result.value\n        2\n        &gt;&gt;&gt; s.value = 23\n        &gt;&gt;&gt; result.value\n        3\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.mod\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = s * 3\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __mul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the product of `self` and `other`.\n\n    Args:\n        other: The value to multiply with.\n\n    Returns:\n        A reactive value for `self.value * other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(4)\n        &gt;&gt;&gt; result = s * 3\n        &gt;&gt;&gt; result.value\n        12\n        &gt;&gt;&gt; s.value = 5\n        &gt;&gt;&gt; result.value\n        15\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.mul\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Return a reactive value for whether <code>self</code> is not equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value != other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s != 5\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nTrue\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __ne__(self, other: Any) -&gt; Computed[bool]:  # type: ignore[override]\n    \"\"\"Return a reactive value for whether `self` is not equal to `other`.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A reactive value for `self.value != other`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(5)\n        &gt;&gt;&gt; result = s != 5\n        &gt;&gt;&gt; result.value\n        False\n        &gt;&gt;&gt; s.value = 6\n        &gt;&gt;&gt; result.value\n        True\n\n        ```\n    \"\"\"\n    return computed(operator.ne)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__neg__","title":"<code>__neg__()</code>","text":"<p>Return a reactive value for the negation of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A reactive value for <code>-self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = -s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n3\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __neg__(self) -&gt; Computed[T]:\n    \"\"\"Return a reactive value for the negation of `self`.\n\n    Returns:\n        A reactive value for `-self.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(5)\n        &gt;&gt;&gt; result = -s\n        &gt;&gt;&gt; result.value\n        -5\n        &gt;&gt;&gt; s.value = -3\n        &gt;&gt;&gt; result.value\n        3\n\n        ```\n    \"\"\"\n    return computed(operator.neg)(self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__or__","title":"<code>__or__(other)</code>","text":"<p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = s | True\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __or__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for the bitwise OR of `self` and `other`.\n\n    Args:\n        other: The value to OR with.\n\n    Returns:\n        A reactive value for `self.value or other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(False)\n        &gt;&gt;&gt; result = s | True\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = True\n        &gt;&gt;&gt; result.value\n        True\n\n        ```\n    \"\"\"\n    return computed(operator.or_)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__pos__","title":"<code>__pos__()</code>","text":"<p>Return a reactive value for the positive of self.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A reactive value for <code>+self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = +s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n3\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __pos__(self) -&gt; Computed[T]:\n    \"\"\"Return a reactive value for the positive of self.\n\n    Returns:\n        A reactive value for `+self.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(-5)\n        &gt;&gt;&gt; result = +s\n        &gt;&gt;&gt; result.value\n        -5\n        &gt;&gt;&gt; s.value = 3\n        &gt;&gt;&gt; result.value\n        3\n\n        ```\n    \"\"\"\n    return computed(operator.pos)(self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__pow__","title":"<code>__pow__(other)</code>","text":"<p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = s ** 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __pow__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `self` raised to the power of `other`.\n\n    Args:\n        other: The exponent.\n\n    Returns:\n        A reactive value for `self.value ** other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(2)\n        &gt;&gt;&gt; result = s ** 3\n        &gt;&gt;&gt; result.value\n        8\n        &gt;&gt;&gt; s.value = 3\n        &gt;&gt;&gt; result.value\n        27\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.pow\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = 3 + s\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __radd__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the sum of `self` and `other`.\n\n    Args:\n        other: The value to add.\n\n    Returns:\n        A reactive value for `self.value + other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(5)\n        &gt;&gt;&gt; result = 3 + s\n        &gt;&gt;&gt; result.value\n        8\n        &gt;&gt;&gt; s.value = 10\n        &gt;&gt;&gt; result.value\n        13\n\n        ```\n    \"\"\"\n    f: Callable[[Y, T], T | Y] = operator.add\n    return computed(f)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rand__","title":"<code>__rand__(other)</code>","text":"<p>Return a reactive value for the bitwise AND of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value and other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False &amp; s\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rand__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for the bitwise AND of `self` and `other`.\n\n    Args:\n        other: The value to AND with.\n\n    Returns:\n        A reactive value for `self.value and other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(True)\n        &gt;&gt;&gt; result = False &amp; s\n        &gt;&gt;&gt; result.value\n        False\n        &gt;&gt;&gt; s.value = True\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.and_)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rdivmod__","title":"<code>__rdivmod__(other)</code>","text":"<p>Return a reactive value for the divmod of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(other, self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = divmod(10, s)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n(2, 2)\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rdivmod__(self, other: Any) -&gt; Computed[tuple[float, float]]:\n    \"\"\"Return a reactive value for the divmod of `self` and `other`.\n\n    Args:\n        other: The value to use as the numerator.\n\n    Returns:\n        A reactive value for `divmod(other, self.value)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(3)\n        &gt;&gt;&gt; result = divmod(10, s)\n        &gt;&gt;&gt; result.value\n        (3, 1)\n        &gt;&gt;&gt; s.value = 4\n        &gt;&gt;&gt; result.value\n        (2, 2)\n\n        ```\n    \"\"\"\n    return cast(Computed[tuple[float, float]], computed(divmod)(other, self))\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rfloordiv__","title":"<code>__rfloordiv__(other)</code>","text":"<p>Return a reactive value for the floor division of <code>other</code> by <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>other.value // self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 // s\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rfloordiv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the floor division of `other` by `self`.\n\n    Args:\n        other: The value to use as the numerator.\n\n    Returns:\n        A reactive value for `other.value // self.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(3)\n        &gt;&gt;&gt; result = 10 // s\n        &gt;&gt;&gt; result.value\n        3\n        &gt;&gt;&gt; s.value = 4\n        &gt;&gt;&gt; result.value\n        2\n\n        ```\n    \"\"\"\n    f: Callable[[Y, T], T | Y] = operator.floordiv\n    return computed(f)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rmod__","title":"<code>__rmod__(other)</code>","text":"<p>Return a reactive value for <code>other</code> modulo <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The dividend.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>other.value % self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 % s\n&gt;&gt;&gt; result.value\n1\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rmod__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `other` modulo `self`.\n\n    Args:\n        other: The dividend.\n\n    Returns:\n        A reactive value for `other.value % self.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(3)\n        &gt;&gt;&gt; result = 10 % s\n        &gt;&gt;&gt; result.value\n        1\n        &gt;&gt;&gt; s.value = 4\n        &gt;&gt;&gt; result.value\n        2\n\n        ```\n    \"\"\"\n    f: Callable[[Y, T], T | Y] = operator.mod\n    return computed(f)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rmul__","title":"<code>__rmul__(other)</code>","text":"<p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = 3 * s\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rmul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the product of `self` and `other`.\n\n    Args:\n        other: The value to multiply with.\n\n    Returns:\n        A reactive value for `self.value * other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(4)\n        &gt;&gt;&gt; result = 3 * s\n        &gt;&gt;&gt; result.value\n        12\n        &gt;&gt;&gt; s.value = 5\n        &gt;&gt;&gt; result.value\n        15\n\n        ```\n    \"\"\"\n    f: Callable[[Y, T], T | Y] = operator.mul\n    return computed(f)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__ror__","title":"<code>__ror__(other)</code>","text":"<p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = True | s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __ror__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for the bitwise OR of `self` and `other`.\n\n    Args:\n        other: The value to OR with.\n\n    Returns:\n        A reactive value for `self.value or other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(False)\n        &gt;&gt;&gt; result = True | s\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = True\n        &gt;&gt;&gt; result.value\n        True\n\n        ```\n    \"\"\"\n    return computed(operator.or_)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__round__","title":"<code>__round__(ndigits=None)</code>","text":"<pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[float]\n</code></pre> <p>Return a reactive value for the rounded value of self.</p> <p>Parameters:</p> Name Type Description Default <code>ndigits</code> <code>int | None</code> <p>Number of decimal places to round to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Computed[int] | Computed[float]</code> <p>A reactive value for <code>round(self.value, ndigits)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3.14159)\n&gt;&gt;&gt; result = round(s, 2)\n&gt;&gt;&gt; result.value\n3.14\n&gt;&gt;&gt; s.value = 2.71828\n&gt;&gt;&gt; result.value\n2.72\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Computed[int] | Computed[float]:\n    \"\"\"Return a reactive value for the rounded value of self.\n\n    Args:\n        ndigits: Number of decimal places to round to.\n\n    Returns:\n        A reactive value for `round(self.value, ndigits)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(3.14159)\n        &gt;&gt;&gt; result = round(s, 2)\n        &gt;&gt;&gt; result.value\n        3.14\n        &gt;&gt;&gt; s.value = 2.71828\n        &gt;&gt;&gt; result.value\n        2.72\n\n        ```\n    \"\"\"\n    if ndigits is None or ndigits == 0:\n        # When ndigits is None or 0, round returns an integer\n        return cast(Computed[int], computed(round)(self, ndigits=ndigits))\n    else:\n        # Otherwise, float\n        return cast(Computed[float], computed(round)(self, ndigits=ndigits))\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rpow__","title":"<code>__rpow__(other)</code>","text":"<p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The base.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 3 ** s\n&gt;&gt;&gt; result.value\n9\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rpow__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `self` raised to the power of `other`.\n\n    Args:\n        other: The base.\n\n    Returns:\n        A reactive value for `self.value ** other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(2)\n        &gt;&gt;&gt; result = 3 ** s\n        &gt;&gt;&gt; result.value\n        9\n        &gt;&gt;&gt; s.value = 3\n        &gt;&gt;&gt; result.value\n        27\n\n        ```\n    \"\"\"\n    f: Callable[[Y, T], T | Y] = operator.pow\n    return computed(f)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rshift__","title":"<code>__rshift__(other)</code>","text":"<p>Return a reactive value for <code>self</code> right-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &gt;&gt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(32)\n&gt;&gt;&gt; result = s &gt;&gt; 2\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 24\n&gt;&gt;&gt; result.value\n6\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `self` right-shifted by `other`.\n\n    Args:\n        other: The number of positions to shift.\n\n    Returns:\n        A reactive value for `self.value &gt;&gt; other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(32)\n        &gt;&gt;&gt; result = s &gt;&gt; 2\n        &gt;&gt;&gt; result.value\n        8\n        &gt;&gt;&gt; s.value = 24\n        &gt;&gt;&gt; result.value\n        6\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.rshift\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rsub__","title":"<code>__rsub__(other)</code>","text":"<p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract from.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>other.value - self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = 15 - s\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n0\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rsub__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the difference of `self` and `other`.\n\n    Args:\n        other: The value to subtract from.\n\n    Returns:\n        A reactive value for `other.value - self.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(10)\n        &gt;&gt;&gt; result = 15 - s\n        &gt;&gt;&gt; result.value\n        5\n        &gt;&gt;&gt; s.value = 15\n        &gt;&gt;&gt; result.value\n        0\n\n        ```\n    \"\"\"\n    f: Callable[[Y, T], T | Y] = operator.sub\n    return computed(f)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rtruediv__","title":"<code>__rtruediv__(other)</code>","text":"<p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 30 / s\n&gt;&gt;&gt; result.value\n15.0\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n10.0\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rtruediv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `self` divided by `other`.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A reactive value for `self.value / other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(2)\n        &gt;&gt;&gt; result = 30 / s\n        &gt;&gt;&gt; result.value\n        15.0\n        &gt;&gt;&gt; s.value = 3\n        &gt;&gt;&gt; result.value\n        10.0\n\n        ```\n    \"\"\"\n    f: Callable[[Y, T], T | Y] = operator.truediv\n    return computed(f)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__rxor__","title":"<code>__rxor__(other)</code>","text":"<p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False ^ s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __rxor__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for the bitwise XOR of `self` and `other`.\n\n    Args:\n        other: The value to XOR with.\n\n    Returns:\n        A reactive value for `self.value ^ other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(True)\n        &gt;&gt;&gt; result = False ^ s\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = False\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.xor)(other, self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Set an attribute on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the attribute via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even if one of its attributes changed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <pre><code>    &gt;&gt;&gt; class Person:\n    ...    def __init__(self, name: str):\n    ...        self.name = name\n    ...    def greet(self) -&gt; str:\n    ...        return f\"Hi, I'm {self.name}!\"\n    &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n    &gt;&gt;&gt; result = s.greet()\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Alice!\"\n    &gt;&gt;&gt; s.name = \"Bob\"  # Modify attribute on Person instance through the reactive value s\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Bob!\"\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    \"\"\"Set an attribute on the underlying `self.value`.\n\n    Note:\n        It is necessary to set the attribute via the Signal, rather than the\n        underlying `signal.value`, to properly notify downstream observers\n        of changes. Reason being, mutable objects that, for example, fallback\n        to id comparison for equality checks will appear as if nothing changed\n        even if one of its attributes changed.\n\n    Args:\n        name: The name of the attribute to access.\n        value: The value to set it to.\n\n    Example:\n        ```py\n            &gt;&gt;&gt; class Person:\n            ...    def __init__(self, name: str):\n            ...        self.name = name\n            ...    def greet(self) -&gt; str:\n            ...        return f\"Hi, I'm {self.name}!\"\n            &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n            &gt;&gt;&gt; result = s.greet()\n            &gt;&gt;&gt; result.value\n            \"Hi, I'm Alice!\"\n            &gt;&gt;&gt; s.name = \"Bob\"  # Modify attribute on Person instance through the reactive value s\n            &gt;&gt;&gt; result.value\n            \"Hi, I'm Bob!\"\n\n        ```\n    \"\"\"\n    if name == \"_value\" or not hasattr(self, \"_value\"):\n        super().__setattr__(name, value)\n    elif hasattr(self.value, name):\n        setattr(self.value, name, value)\n        self.notify()\n    else:\n        super().__setattr__(name, value)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an item on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the item via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even an element of the object is changed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key to change.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <p>```py</p> <p>s = Signal([1, 2, 3]) result = computed(sum)(s) result.value 6 s[1] = 4 result.value 8</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def __setitem__(self, key: Any, value: Any) -&gt; None:\n    \"\"\"Set an item on the underlying `self.value`.\n\n    Note:\n        It is necessary to set the item via the Signal, rather than the\n        underlying `signal.value`, to properly notify downstream observers\n        of changes. Reason being, mutable objects that, for example, fallback\n        to id comparison for equality checks will appear as if nothing changed\n        even an element of the object is changed.\n\n    Args:\n        key: The key to change.\n        value: The value to set it to.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal([1, 2, 3])\n        &gt;&gt;&gt; result = computed(sum)(s)\n        &gt;&gt;&gt; result.value\n        6\n        &gt;&gt;&gt; s[1] = 4\n        &gt;&gt;&gt; result.value\n        8\n    \"\"\"\n    if isinstance(self.value, (list, dict)):\n        self.value[key] = value\n        self.notify()\n    else:\n        raise TypeError(f\"'{type(self.value).__name__}' object does not support item assignment\")\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__str__","title":"<code>__str__()</code>","text":"<p>Return a string of the current value.</p> Note <p>This is not reactive.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of <code>self.value</code>.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string of the current value.\n\n    Note:\n        This is not reactive.\n\n    Returns:\n        A string representation of `self.value`.\n    \"\"\"\n    return str(self.value)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value - other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s - 3\n&gt;&gt;&gt; result.value\n7\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n12\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __sub__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for the difference of `self` and `other`.\n\n    Args:\n        other: The value to subtract.\n\n    Returns:\n        A reactive value for `self.value - other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(10)\n        &gt;&gt;&gt; result = s - 3\n        &gt;&gt;&gt; result.value\n        7\n        &gt;&gt;&gt; s.value = 15\n        &gt;&gt;&gt; result.value\n        12\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.sub\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s / 4\n&gt;&gt;&gt; result.value\n5.0\n&gt;&gt;&gt; s.value = 30\n&gt;&gt;&gt; result.value\n7.5\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __truediv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a reactive value for `self` divided by `other`.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A reactive value for `self.value / other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(20)\n        &gt;&gt;&gt; result = s / 4\n        &gt;&gt;&gt; result.value\n        5.0\n        &gt;&gt;&gt; s.value = 30\n        &gt;&gt;&gt; result.value\n        7.5\n\n        ```\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.truediv\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__trunc__","title":"<code>__trunc__()</code>","text":"<p>Return a reactive value for the truncated value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A reactive value for <code>math.trunc(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import trunc\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = trunc(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = -4.01\n&gt;&gt;&gt; result.value\n-4\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __trunc__(self) -&gt; Computed[T]:\n    \"\"\"Return a reactive value for the truncated value of `self`.\n\n    Returns:\n        A reactive value for `math.trunc(self.value)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; from math import trunc\n        &gt;&gt;&gt; s = Signal(3.99)\n        &gt;&gt;&gt; result = trunc(s)\n        &gt;&gt;&gt; result.value\n        3\n        &gt;&gt;&gt; s.value = -4.01\n        &gt;&gt;&gt; result.value\n        -4\n\n        ```\n    \"\"\"\n    return computed(math.trunc)(self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.__xor__","title":"<code>__xor__(other)</code>","text":"<p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s ^ False\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def __xor__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for the bitwise XOR of `self` and `other`.\n\n    Args:\n        other: The value to XOR with.\n\n    Returns:\n        A reactive value for `self.value ^ other.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(True)\n        &gt;&gt;&gt; result = s ^ False\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = False\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.xor)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.bool","title":"<code>bool()</code>","text":"<p>Return a reactive value for the boolean value of <code>self</code>.</p> Note <p><code>__bool__</code> cannot be implemented to return a non-<code>bool</code>, so it is provided as a method.</p> <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>bool(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(1)\n&gt;&gt;&gt; result = s.bool()\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 0\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def bool(self) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for the boolean value of `self`.\n\n    Note:\n        `__bool__` cannot be implemented to return a non-`bool`, so it is provided as a method.\n\n    Returns:\n        A reactive value for `bool(self.value)`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(1)\n        &gt;&gt;&gt; result = s.bool()\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = 0\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(bool)(self)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.contains","title":"<code>contains(other)</code>","text":"<p>Return a reactive value for whether <code>other</code> is in <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to check for containment.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>other in self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4])\n&gt;&gt;&gt; result = s.contains(3)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = [5, 6, 7, 8]\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def contains(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for whether `other` is in `self`.\n\n    Args:\n        other: The value to check for containment.\n\n    Returns:\n        A reactive value for `other in self.value`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal([1, 2, 3, 4])\n        &gt;&gt;&gt; result = s.contains(3)\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = [5, 6, 7, 8]\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.contains)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.eq","title":"<code>eq(other)</code>","text":"<p>Return a reactive value for whether <code>self</code> equals other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value == other.</p> Note <p>We can't overload <code>__eq__</code> because it interferes with basic Python operations.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s.eq(10)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def eq(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for whether `self` equals other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A reactive value for self.value == other.\n\n    Note:\n        We can't overload `__eq__` because it interferes with basic Python operations.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(10)\n        &gt;&gt;&gt; result = s.eq(10)\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = 25\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.eq)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.is_not","title":"<code>is_not(other)</code>","text":"<p>Return a reactive value for whether <code>self</code> is not other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value is not other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; other = None\n&gt;&gt;&gt; result = s.is_not(other)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = None\n&gt;&gt;&gt; result.value\nFalse\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def is_not(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a reactive value for whether `self` is not other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A reactive value for self.value is not other.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; s = Signal(10)\n        &gt;&gt;&gt; other = None\n        &gt;&gt;&gt; result = s.is_not(other)\n        &gt;&gt;&gt; result.value\n        True\n        &gt;&gt;&gt; s.value = None\n        &gt;&gt;&gt; result.value\n        False\n\n        ```\n    \"\"\"\n    return computed(operator.is_not)(self, other)\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.notify","title":"<code>notify()</code>","text":"<p>Notify all observers by calling their <code>update</code> method.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def notify(self) -&gt; None:\n    \"\"\"Notify all observers by calling their ``update`` method.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/#signified.ReactiveMixIn.where","title":"<code>where(a, b)</code>","text":"<p>Return a reactive value for <code>a</code> if <code>self</code> is <code>True</code>, else <code>b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>HasValue[A]</code> <p>The value to return if <code>self</code> is <code>True</code>.</p> required <code>b</code> <code>HasValue[B]</code> <p>The value to return if <code>self</code> is <code>False</code>.</p> required <p>Returns:</p> Type Description <code>Computed[A | B]</code> <p>A reactive value for <code>a if self.value else b</code>.</p> Example <pre><code>&gt;&gt;&gt; condition = Signal(True)\n&gt;&gt;&gt; result = condition.where(\"Yes\", \"No\")\n&gt;&gt;&gt; result.value\n'Yes'\n&gt;&gt;&gt; condition.value = False\n&gt;&gt;&gt; result.value\n'No'\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def where(self, a: HasValue[A], b: HasValue[B]) -&gt; Computed[A | B]:\n    \"\"\"Return a reactive value for `a` if `self` is `True`, else `b`.\n\n    Args:\n        a: The value to return if `self` is `True`.\n        b: The value to return if `self` is `False`.\n\n    Returns:\n        A reactive value for `a if self.value else b`.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; condition = Signal(True)\n        &gt;&gt;&gt; result = condition.where(\"Yes\", \"No\")\n        &gt;&gt;&gt; result.value\n        'Yes'\n        &gt;&gt;&gt; condition.value = False\n        &gt;&gt;&gt; result.value\n        'No'\n\n        ```\n    \"\"\"\n\n    @computed\n    def ternary(a: A, b: B, self: Any) -&gt; A | B:\n        return a if self else b\n\n    return ternary(a, b, self)\n</code></pre>"},{"location":"api_reference/#signified.Signal","title":"<code>Signal</code>","text":"<p>               Bases: <code>Variable[NestedValue[T], T]</code></p> <p>A container that holds a reactive value.</p> Note <p>A Signal is a Generic container with type <code>T</code>. <code>T</code> is defined as the type that would be returned by <code>signal.value</code> which automatically handles unnesting reactive values. For example the below expression would be inferred by <code>pyright</code> to be of type <code>Signal[str]</code>. <pre><code>Signal(Signal(Signal(\"abc\")))  # Signal[str]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NestedValue[T]</code> <p>The initial value of the signal, which can be a nested structure.</p> required <p>Attributes:</p> Name Type Description <code>_value</code> <code>NestedValue[T]</code> <p>The current value of the signal.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>class Signal(Variable[NestedValue[T], T]):\n    \"\"\"A container that holds a reactive value.\n\n    Note:\n        A Signal is a Generic container with type ``T``. ``T`` is defined as the type\n        that would be returned by ``signal.value`` which automatically handles\n        unnesting reactive values. For example the below expression would be\n        inferred by ``pyright`` to be of type ``Signal[str]``.\n        ```py\n        Signal(Signal(Signal(\"abc\")))  # Signal[str]\n        ```\n\n    Args:\n        value: The initial value of the signal, which can be a nested structure.\n\n    Attributes:\n        _value (NestedValue[T]): The current value of the signal.\n    \"\"\"\n\n    def __init__(self, value: NestedValue[T]) -&gt; None:\n        super().__init__()\n        self._value: T = cast(T, value)\n        self.observe(value)\n\n    @property\n    def value(self) -&gt; T:\n        \"\"\"Get or set the current value.\n\n        When setting a value, observers will be notified if the value has changed.\n\n        Returns:\n            The current value (when getting).\n        \"\"\"\n        return unref(self._value)\n\n    @value.setter\n    def value(self, new_value: HasValue[T]) -&gt; None:\n        old_value = self._value\n        change = new_value != old_value\n        if isinstance(change, np.ndarray):\n            change = change.any()\n        elif callable(old_value):\n            change = True\n        if change:\n            self._value = cast(T, new_value)\n            self.unobserve(old_value)\n            self.observe(new_value)\n            self.notify()\n\n    @contextmanager\n    def at(self, value: T) -&gt; Generator[None, None, None]:\n        \"\"\"Temporarily set the signal to a given value within a context.\n\n        Args:\n            value: The temporary value to set.\n\n        Yields:\n            None\n\n        Example:\n            ```py\n            &gt;&gt;&gt; x = Signal(2)\n            &gt;&gt;&gt; x_plus_2 = x + 2\n            &gt;&gt;&gt; x_plus_2.value\n            4\n            &gt;&gt;&gt; with x.at(8):\n            ...     x_plus_2.value\n            10\n\n            ```\n        \"\"\"\n        before = self.value\n        try:\n            before = self.value\n            self.value = value\n            yield\n        finally:\n            self.value = before\n\n    def update(self) -&gt; None:\n        \"\"\"Update the signal and notify subscribers.\"\"\"\n        self.notify()\n</code></pre>"},{"location":"api_reference/#signified.Signal.value","title":"<code>value: T</code>  <code>property</code> <code>writable</code>","text":"<p>Get or set the current value.</p> <p>When setting a value, observers will be notified if the value has changed.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value (when getting).</p>"},{"location":"api_reference/#signified.Signal.at","title":"<code>at(value)</code>","text":"<p>Temporarily set the signal to a given value within a context.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The temporary value to set.</p> required <p>Yields:</p> Type Description <code>None</code> <p>None</p> Example <pre><code>&gt;&gt;&gt; x = Signal(2)\n&gt;&gt;&gt; x_plus_2 = x + 2\n&gt;&gt;&gt; x_plus_2.value\n4\n&gt;&gt;&gt; with x.at(8):\n...     x_plus_2.value\n10\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>@contextmanager\ndef at(self, value: T) -&gt; Generator[None, None, None]:\n    \"\"\"Temporarily set the signal to a given value within a context.\n\n    Args:\n        value: The temporary value to set.\n\n    Yields:\n        None\n\n    Example:\n        ```py\n        &gt;&gt;&gt; x = Signal(2)\n        &gt;&gt;&gt; x_plus_2 = x + 2\n        &gt;&gt;&gt; x_plus_2.value\n        4\n        &gt;&gt;&gt; with x.at(8):\n        ...     x_plus_2.value\n        10\n\n        ```\n    \"\"\"\n    before = self.value\n    try:\n        before = self.value\n        self.value = value\n        yield\n    finally:\n        self.value = before\n</code></pre>"},{"location":"api_reference/#signified.Signal.update","title":"<code>update()</code>","text":"<p>Update the signal and notify subscribers.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the signal and notify subscribers.\"\"\"\n    self.notify()\n</code></pre>"},{"location":"api_reference/#signified.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>ABC</code>, <code>_HasValue[Y]</code>, <code>ReactiveMixIn[T]</code></p> <p>An abstract base class for reactive values.</p> <p>A reactive value is an object that can be observed by observer for changes and can notify observers when its value changes. This class implements both the observer and observable patterns.</p> <p>This class implements both the observer and observable pattern.</p> <p>Subclasses should implement the <code>update</code> method.</p> <p>Attributes:</p> Name Type Description <code>_observers</code> <code>list[Observer]</code> <p>List of observers subscribed to this variable.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>class Variable(ABC, _HasValue[Y], ReactiveMixIn[T]):  # type: ignore[misc]\n    \"\"\"An abstract base class for reactive values.\n\n    A reactive value is an object that can be observed by observer for changes and\n    can notify observers when its value changes. This class implements both the observer\n    and observable patterns.\n\n    This class implements both the observer and observable pattern.\n\n    Subclasses should implement the `update` method.\n\n    Attributes:\n        _observers (list[Observer]): List of observers subscribed to this variable.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the variable.\"\"\"\n        self._observers: list[Observer] = []\n\n    def subscribe(self, observer: Observer) -&gt; None:\n        \"\"\"Subscribe an observer to this variable.\n\n        Args:\n            observer: The observer to subscribe.\n        \"\"\"\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def unsubscribe(self, observer: Observer) -&gt; None:\n        \"\"\"Unsubscribe an observer from this variable.\n\n        Args:\n            observer: The observer to unsubscribe.\n        \"\"\"\n        if observer in self._observers:\n            self._observers.remove(observer)\n\n    def observe(self, items: Any) -&gt; Self:\n        \"\"\"Subscribe the observer (`self`) to all items that are Observable.\n\n        This method handles arbitrarily nested iterables.\n\n        Args:\n            items: A single item, an iterable, or a nested structure of items to potentially subscribe to.\n\n        Returns:\n            self\n        \"\"\"\n\n        def _observe(item: Any) -&gt; None:\n            if isinstance(item, Variable) and item is not self:\n                item.subscribe(self)\n            elif isinstance(item, Iterable) and not isinstance(item, str):\n                for sub_item in item:\n                    _observe(sub_item)\n\n        _observe(items)\n        return self\n\n    def unobserve(self, items: Any) -&gt; Self:\n        \"\"\"Unsubscribe the observer (`self`) from all items that are Observable.\n\n        Args:\n            items: A single item or an iterable of items to potentially unsubscribe from.\n\n        Returns:\n            self\n        \"\"\"\n\n        def _unobserve(item: Any) -&gt; None:\n            if isinstance(item, Variable) and item is not self:\n                item.subscribe(self)\n            elif isinstance(item, Iterable) and not isinstance(item, str):\n                for sub_item in item:\n                    _unobserve(sub_item)\n\n        _unobserve(items)\n        return self\n\n    def notify(self) -&gt; None:\n        \"\"\"Notify all observers by calling their update method.\"\"\"\n        for observer in self._observers:\n            observer.update()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Represent the object in a way that shows the inner value.\"\"\"\n        return f\"&lt;{self.value}&gt;\"\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"Update method to be overridden by subclasses.\n\n        Raises:\n            NotImplementedError: If not overridden by a subclass.\n        \"\"\"\n        raise NotImplementedError(\"Update method should be overridden by subclasses\")\n\n    def _ipython_display_(self) -&gt; None:\n        handle = display(self.value, display_id=True)\n        assert handle is not None\n        IPythonObserver(self, handle)\n</code></pre>"},{"location":"api_reference/#signified.Variable.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the variable.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the variable.\"\"\"\n    self._observers: list[Observer] = []\n</code></pre>"},{"location":"api_reference/#signified.Variable.__repr__","title":"<code>__repr__()</code>","text":"<p>Represent the object in a way that shows the inner value.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Represent the object in a way that shows the inner value.\"\"\"\n    return f\"&lt;{self.value}&gt;\"\n</code></pre>"},{"location":"api_reference/#signified.Variable.notify","title":"<code>notify()</code>","text":"<p>Notify all observers by calling their update method.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def notify(self) -&gt; None:\n    \"\"\"Notify all observers by calling their update method.\"\"\"\n    for observer in self._observers:\n        observer.update()\n</code></pre>"},{"location":"api_reference/#signified.Variable.observe","title":"<code>observe(items)</code>","text":"<p>Subscribe the observer (<code>self</code>) to all items that are Observable.</p> <p>This method handles arbitrarily nested iterables.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item, an iterable, or a nested structure of items to potentially subscribe to.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def observe(self, items: Any) -&gt; Self:\n    \"\"\"Subscribe the observer (`self`) to all items that are Observable.\n\n    This method handles arbitrarily nested iterables.\n\n    Args:\n        items: A single item, an iterable, or a nested structure of items to potentially subscribe to.\n\n    Returns:\n        self\n    \"\"\"\n\n    def _observe(item: Any) -&gt; None:\n        if isinstance(item, Variable) and item is not self:\n            item.subscribe(self)\n        elif isinstance(item, Iterable) and not isinstance(item, str):\n            for sub_item in item:\n                _observe(sub_item)\n\n    _observe(items)\n    return self\n</code></pre>"},{"location":"api_reference/#signified.Variable.subscribe","title":"<code>subscribe(observer)</code>","text":"<p>Subscribe an observer to this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to subscribe.</p> required Source code in <code>src/signified/__init__.py</code> <pre><code>def subscribe(self, observer: Observer) -&gt; None:\n    \"\"\"Subscribe an observer to this variable.\n\n    Args:\n        observer: The observer to subscribe.\n    \"\"\"\n    if observer not in self._observers:\n        self._observers.append(observer)\n</code></pre>"},{"location":"api_reference/#signified.Variable.unobserve","title":"<code>unobserve(items)</code>","text":"<p>Unsubscribe the observer (<code>self</code>) from all items that are Observable.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item or an iterable of items to potentially unsubscribe from.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def unobserve(self, items: Any) -&gt; Self:\n    \"\"\"Unsubscribe the observer (`self`) from all items that are Observable.\n\n    Args:\n        items: A single item or an iterable of items to potentially unsubscribe from.\n\n    Returns:\n        self\n    \"\"\"\n\n    def _unobserve(item: Any) -&gt; None:\n        if isinstance(item, Variable) and item is not self:\n            item.subscribe(self)\n        elif isinstance(item, Iterable) and not isinstance(item, str):\n            for sub_item in item:\n                _unobserve(sub_item)\n\n    _unobserve(items)\n    return self\n</code></pre>"},{"location":"api_reference/#signified.Variable.unsubscribe","title":"<code>unsubscribe(observer)</code>","text":"<p>Unsubscribe an observer from this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to unsubscribe.</p> required Source code in <code>src/signified/__init__.py</code> <pre><code>def unsubscribe(self, observer: Observer) -&gt; None:\n    \"\"\"Unsubscribe an observer from this variable.\n\n    Args:\n        observer: The observer to unsubscribe.\n    \"\"\"\n    if observer in self._observers:\n        self._observers.remove(observer)\n</code></pre>"},{"location":"api_reference/#signified.Variable.update","title":"<code>update()</code>  <code>abstractmethod</code>","text":"<p>Update method to be overridden by subclasses.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not overridden by a subclass.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"Update method to be overridden by subclasses.\n\n    Raises:\n        NotImplementedError: If not overridden by a subclass.\n    \"\"\"\n    raise NotImplementedError(\"Update method should be overridden by subclasses\")\n</code></pre>"},{"location":"api_reference/#signified.as_signal","title":"<code>as_signal(val)</code>","text":"<p>Convert a value to a <code>Signal</code> if it's not already a reactive value.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>HasValue[T]</code> <p>The value to convert.</p> required <p>Returns:</p> Type Description <code>Signal[T]</code> <p>The value as a <code>Signal</code> or the original reactive value.</p> Example <p>```py</p> <p>as_signal(2) &lt;2&gt; as_signal(Signal(2)) &lt;2&gt;</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def as_signal(val: HasValue[T]) -&gt; Signal[T]:\n    \"\"\"Convert a value to a [`Signal`][signified.Signal] if it's not already a reactive value.\n\n    Args:\n        val: The value to convert.\n\n    Returns:\n        The value as a [`Signal`][signified.Signal] or the original reactive value.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; as_signal(2)\n        &lt;2&gt;\n        &gt;&gt;&gt; as_signal(Signal(2))\n        &lt;2&gt;\n    \"\"\"\n    return cast(Signal[T], val) if isinstance(val, Variable) else Signal(val)\n</code></pre>"},{"location":"api_reference/#signified.computed","title":"<code>computed(func)</code>","text":"<p>Decorate the function to return a reactive value.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>The function to compute the value.</p> required <p>Returns:</p> Type Description <code>Callable[..., Computed[R]]</code> <p>A function that returns a reactive value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = Signal([1,2,3])\n&gt;&gt;&gt; sum_x = computed(sum)(x)\n&gt;&gt;&gt; sum_x\n&lt;6&gt;\n&gt;&gt;&gt; x.value = range(10)\n&gt;&gt;&gt; sum_x\n&lt;45&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; @computed\n... def my_add(x, y):\n...     return x + y\n&gt;&gt;&gt; x = Signal(2)\n&gt;&gt;&gt; my_add(x, 10)\n&lt;12&gt;\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def computed(func: Callable[..., R]) -&gt; Callable[..., Computed[R]]:\n    \"\"\"Decorate the function to return a reactive value.\n\n    Args:\n        func: The function to compute the value.\n\n    Returns:\n        A function that returns a reactive value.\n\n    Examples:\n        ```py\n        &gt;&gt;&gt; x = Signal([1,2,3])\n        &gt;&gt;&gt; sum_x = computed(sum)(x)\n        &gt;&gt;&gt; sum_x\n        &lt;6&gt;\n        &gt;&gt;&gt; x.value = range(10)\n        &gt;&gt;&gt; sum_x\n        &lt;45&gt;\n\n        ```\n\n        ```py\n        &gt;&gt;&gt; @computed\n        ... def my_add(x, y):\n        ...     return x + y\n        &gt;&gt;&gt; x = Signal(2)\n        &gt;&gt;&gt; my_add(x, 10)\n        &lt;12&gt;\n\n        ```\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Computed[R]:\n        def compute_func() -&gt; R:\n            resolved_args = tuple(unref(arg) for arg in args)\n            resolved_kwargs = {key: unref(value) for key, value in kwargs.items()}\n            return func(*resolved_args, **resolved_kwargs)\n\n        return Computed(compute_func, (*args, *kwargs.values()))\n\n    return wrapper\n</code></pre>"},{"location":"api_reference/#signified.has_value","title":"<code>has_value(obj, type_)</code>","text":"<p>Check if an object has a value of a specific type.</p> Note <p>This serves as a TypeGuard to help support type narrowing.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check.</p> required <code>type_</code> <code>type[T]</code> <p>The type to check against.</p> required <p>Returns:</p> Type Description <code>TypeGuard[HasValue[T]]</code> <p>True if the object has a value of the specified type.</p> Example <pre><code>&gt;&gt;&gt; has_value(Signal(\"abc\"), str)\nTrue\n</code></pre> Source code in <code>src/signified/__init__.py</code> <pre><code>def has_value(obj: Any, type_: type[T]) -&gt; TypeGuard[HasValue[T]]:\n    \"\"\"Check if an object has a value of a specific type.\n\n    Note:\n        This serves as a TypeGuard to help support type narrowing.\n\n    Args:\n        obj: The object to check.\n        type_: The type to check against.\n\n    Returns:\n        True if the object has a value of the specified type.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; has_value(Signal(\"abc\"), str)\n        True\n\n        ```\n    \"\"\"\n    return isinstance(unref(obj), type_)\n</code></pre>"},{"location":"api_reference/#signified.reactive_method","title":"<code>reactive_method(*dep_names)</code>","text":"<p>Decorate the method to return a reactive value.</p> <p>Parameters:</p> Name Type Description Default <code>*dep_names</code> <code>str</code> <p>Names of object attributes to track as dependencies.</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., T]], Callable[..., Computed[T]]]</code> <p>A decorator function.</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def reactive_method(*dep_names: str) -&gt; Callable[[Callable[..., T]], Callable[..., Computed[T]]]:\n    \"\"\"Decorate the method to return a reactive value.\n\n    Args:\n        *dep_names: Names of object attributes to track as dependencies.\n\n    Returns:\n        A decorator function.\n    \"\"\"\n\n    def decorator(func: Callable[..., T]) -&gt; Callable[..., Computed[T]]:\n        @wraps(func)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -&gt; Computed[T]:\n            object_deps = [getattr(self, name) for name in dep_names if hasattr(self, name)]\n            all_deps = (*object_deps, *args, *kwargs.values())\n            return Computed(lambda: func(self, *args, **kwargs), all_deps)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_reference/#signified.unref","title":"<code>unref(value)</code>","text":"<p>Dereference a value, resolving any nested reactive variables.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>HasValue[T]</code> <p>The value to dereference.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The dereferenced value.</p> Example <p>```py</p> <p>x = Signal(Signal(Signal(2))) unref(x) 2</p> Source code in <code>src/signified/__init__.py</code> <pre><code>def unref(value: HasValue[T]) -&gt; T:\n    \"\"\"Dereference a value, resolving any nested reactive variables.\n\n    Args:\n        value: The value to dereference.\n\n    Returns:\n        The dereferenced value.\n\n    Example:\n        ```py\n        &gt;&gt;&gt; x = Signal(Signal(Signal(2)))\n        &gt;&gt;&gt; unref(x)\n        2\n    \"\"\"\n    while isinstance(value, Variable):\n        value = value._value\n    return cast(T, value)\n</code></pre>"},{"location":"changes/","title":"Change Log","text":""},{"location":"changes/#015","title":"0.1.5","text":"<p>Features * Added <code>__setitem__</code> and <code>__setattr</code> methods for generating reactive values.</p> <p>Docs * Added examples to docstrings (in doctest format).</p> <p>Bug Fixes * Under several conditions, Reactive values generated from <code>__call__</code> and <code>`__getitem__</code> weren't updating when an upstream observable was updated.</p> <p>Typing * Improve type inference for <code>__call__</code> generated reactive values.</p>"},{"location":"changes/#014","title":"0.1.4","text":"<p>Minor changes to packaging and documentation</p>"},{"location":"changes/#011","title":"0.1.1","text":"<p>Initial release.</p>"},{"location":"usage/","title":"Usage Examples","text":""},{"location":"usage/#simple-arithmetic","title":"Simple Arithmetic","text":"<pre><code>from signified import Signal\n\na = Signal(3)\nb = Signal(4)\n\nc = (a ** 2 + b ** 2) ** 0.5\n\nassert c.value == 5\n\na.value = 5\nb.value = 12\n\nassert c.value == 13\n</code></pre>"},{"location":"usage/#a-computed-function","title":"A Computed Function","text":"<pre><code>from signified import Signal, computed\n\na = Signal(3)\n\n@computed\ndef pow(x: int, n: int) -&gt; int:\n    return x ** n\n\na_squared = pow(a, 2)\n\nassert a_squared.value == 9\n\na.value = 5\n\nassert a_squared.value == 25\n</code></pre>"}]}